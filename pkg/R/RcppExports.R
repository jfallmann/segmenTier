# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Pearson product-moment correlation coefficient
#'
#' Incremental calculation of the Pearson correlation coefficient between
#' two vectors for calculation within Rcpp functions
#' \code{\link{clusterCor_c}}.
#' @param x numeric vector
#' @param y numeric vector
#' @details Simply calculates Pearson's product-moment correlation
#' between vectors \code{x} and \code{y}. 
myPearson <- function(x, y) {
    .Call('_segmenTier_myPearson', PACKAGE = 'segmenTier', x, y)
}

#' Calculates data-cluster similarity.
#' @details calculates Pearson's product-moment correlation coefficients
#' of original data to cluster centers as used in the scoring function "icor".
#' @param data original data matrix
#' @param clusters cluster centers
#' @return Returns a data-cluster correlation matrix as used in
#' scoring function "icor".
#'@export
clusterCor_c <- function(data, clusters) {
    .Call('_segmenTier_clusterCor_c', PACKAGE = 'segmenTier', data, clusters)
}

#' Reports the maximally correlating cluster for each data point.
#' @details Calculates Pearson's product-moment correlation of each data
#' to clusters and report the (first!) cluster which had max correlation.
#' Note that this can lead to amibiguities since several clusters may
#' reach the same maximum.
#' TODO: this seems not be used anywhere, remove?
#' @param mincor minimal correlation to be considered
#' @param warn if set to 1/TRUE then the occurence of multiple maxima
#' is tested and a warning issued
#' @inheritParams clusterCor_c
#'@export
clusterMaxCor_c <- function(data, clusters, mincor = 0.0, warn = 0L) {
    .Call('_segmenTier_clusterMaxCor_c', PACKAGE = 'segmenTier', data, clusters, mincor, warn)
}

icor <- function(k, j, c, seq, M, csim) {
    .Call('_segmenTier_icor', PACKAGE = 'segmenTier', k, j, c, seq, M, csim)
}

ccor <- function(k, j, c, seq, M, csim) {
    .Call('_segmenTier_ccor', PACKAGE = 'segmenTier', k, j, c, seq, M, csim)
}

#' segmenTier's dynamic programming routine
#' 
#' @details This is \code{\link{segmenTier}}'s core dynamic programing
#' routine. It constructs the total score matrix S(i,c), based on
#' the passed scoring function ("icor" or "ccor"), and length penalty
#' \code{M}. "Nuissance" cluster "0" can have a smaller penalty \code{Mn}
#' to allow for shorter distance between "real" segments.
#'
#' Scoring function "icor" calculates the sum of similarities of
#' data at positions k:i to cluster centers c over all k and i.
#' The similarities are calculated e.g., as a (Pearson) correlation between
#' the data at individual positions and the tested cluster c center.
#'
#' Scoring function "ccor" calculates the sum of similarities
#' between the clusters at positions k:i to cluster c over all k and i.
#'
#' Scoring function "ccls" is a special case of "ccor" and is NOT handled
#' here, but is reflected in the cluster similarity matrix \code{csim}. It
#' is handled and automatically constructed in the R wrapper 
#' \code{\link{segmentClusters}}, and merely counts the 
#' number of clusters in sequence k:i, over all k and i, that are identical
#' to the tested cluster \code{c}, and sub-tracts 
#' a penalty for the count of non-identical clusters.
#' @param seq the cluster sequence (where clusters at positions k:i are
#' considered). Note, that unlike the R wrapper, clustering numbers
#' here are 0-based, where 0 is the nuissance cluster.
#' @param C the list of clusters, including nuissance cluster '0', see 
#' \code{seq}
#' @param score the scoring function to be used, one of "ccor" or "icor";
#' the scoring function "ccls" is a special case of "ccor" and should
#' be handled via the similarity function (matrix) "csim" as e.g. done
#' by the R wrapper function \code{\link{segmentClusters}}. See "details".
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as an accumulating penalty that must be
#' "overcome" by good score.
#' @param Mn minimal sequence length for nuissance cluster, Mn<M will allow
#' shorter distances between segments
#' @param csim a matrix, providing either the cluster-cluster (scoring 
#' function "ccor") or the position-cluster similarity function
#' @param multi if multiple \code{k} are found which return the same maximal
#' score, should the "max" (shorter segment) or "min" (longer segment) be used?
#' This has little effect on real-life large data sets, since the situation
#' will rarely occur. Default is "max".
#' @return Returns the total score matrix \code{S(i,c)} and the matrix 
#' \code{K(i,c)} which stores the position \code{k} which delivered
#' the maximal score at position \code{i}. This is used in the back-tracing
#' phase.
#' @references Machne, Murray & Stadler (2017)
#'     <doi:10.1038/s41598-017-12401-8>
#' @export
calculateScore <- function(seq, C, score, csim, M, Mn, multi = "max") {
    .Call('_segmenTier_calculateScore', PACKAGE = 'segmenTier', seq, C, score, csim, M, Mn, multi)
}

