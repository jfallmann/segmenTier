---
title: "segmenTier: Similarity-Based Segmentation of Multi-Dimensional Signals"
author: "Rainer Machne, Douglas B. Murray, Peter F. Stadler"
date: "`r Sys.Date()`"
output: 
    rmarkdown::html_vignette:
      toc: true
bibliography: segmenTier.bib
vignette: >
  %\VignetteIndexEntry{segmenTier}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

![](logo.png) 

`segmenTier` is a dynamic programming solution to segmentation based
on maximization of arbitrary similarity measures within segments
as developed in @Machne2017.

In addition to the core algorithm, the package provides time-series
processing and clustering functions as described in the
publication. These are generally applicable where a `k-means`
clustering yields meaningful results, and have been specifically
developed for clustering of the Discrete Fourier Transform of periodic
gene expression data ("circadian" or "yeast metabolic oscillations").

This clustering approach is outlined in the supplemental material of
@Machne2012, and here is used as a basis of segment similarity
measures.  Note, that the functions `processTimeseries` and
`clusterTimeseries`, can also be used as stand-alone tools for
periodic time-series analysis and clustering.


# Theory

The ideas and theory behind the package is detailed in @Machne2017,
here we provide a synopsis.

## Dynamic Programming Recursion

`segmenTier`'s input is a clustering
$\mathcal{C}_{\alpha}\subseteq\mathbb{X}$, $\alpha=1,\dots N$.
`segmenTier` then solves the recursion:

\begin{equation}
  S_{k,\alpha} =
  \max_{j\le k} \max_{\beta\ne\alpha}
                 S_{j-1,\beta} + s(j,k,\alpha) - M\;,
\label{eq:01}
\end{equation}

where $s(j,k,\alpha)$ is a scoring function that measures the similarity
of a segment from position $j$ to $k$ to cluster
$\mathcal{C}_\alpha$, *e.g.* based on Pearson correlation to cluster
centers, and $M$ is a penalty incurred by the use of a new segment, a
fixed cost for each jump that allows to fine-tune minimal segment
lengths. Backtracing the maximal scores $S(k,\alpha)$ then provides
both segment borders and segment cluster association.

Clustering tools are provided in the package, and a full pipeline is
available for clustering the Fourier-transform of oscillatory RNA-seq
time-series, ("circadian or metabolic oscillations"). See **Quick
Guide**.

## Scoring Functions 

Three scoring functions are available. They all sum up a similarity
measure between positions $i$ and $k$ and clusters $\mathcal{C}$.

The first two rely on a clustering of all positions $x$

\begin{equation}
s(j,k,\alpha) = \sum_{i=j}^k Q(\mathcal{C}_i,\mathcal{C}_\alpha)
\end{equation}

where $\mathcal{C}_i$ is the cluster label of data row $x_i$, and
$Q(\mathcal{C},\mathcal{D})$ is an, in principle arbitrary, similarity
measure for the two clusters. The most basic choice is
$Q(\mathcal{C},\mathcal{C})=1$ and $Q(\mathcal{C},\mathcal{D})=a<0$
for $\mathcal{C}\ne\mathcal{D}$.  This case is available as scoring
function "ccls" (argument `S="ccls"`) with a default value $a=-2$,
and requires as sole input a vector of cluster labels.

For our application, an RNAseq timeseries, the Pearson correlation
between the cluster centroids (mean values) proofed useful:
$Q(\mathcal{C},\mathcal{D})= \text{corr}(\bar x_{\mathcal{C}},\bar
x_{\mathcal{D}})$ is pre-calculated as a cluster-cluster correlation
matrix by `segmenTier`s interface to `kmeans` clustering, and
available as scoring function "ccor" (`S="ccor"`).

The third option does not rely on a clustering of all positions, and
would in principle allow to use cluster centroids that are independently
derived, eg. from only a subset of the data. The scoring function

\begin{equation}
  s(j,k,\alpha) = \sum_{i=j}^k \tilde\sigma(x_i,\mathcal{C}_{\alpha})
\end{equation}

measures the similarity of each data row $x_i$ to a cluster centroid,
is again implemented as Pearson correlations,
$\tilde\sigma(x_i,\mathcal{C}_{\alpha})= \text{corr}(x_i,\bar
x_{\mathcal{C}_{\alpha}})$, pre-calculated by the clustering
interface, and available as scoring function "icor" (`S="icor"`).

## Scaling & Nuisance

It proofed useful to further emphasize correlation derived similarities
by an exponent $\epsilon>1$, which de-emphasizes weakly positive
or negative correlations, and this is available as argument `E` for
all scoring functions. Signs are preserved, allowing for even-valued
exponents.

Additionally, one can define a nuisance cluster in pre-processing of
the data, eg. total data values or data-cluster correlations below a
certain threshold, and enforce such segments by using a higher
similarity/dis-similarity value, argument `nui` in our implementation.

The figure below shows the effects of scaling Pearson correlations
by `E` and choosing a "nui>1$.

```{r, echo=FALSE, fig.width=4, fig.height=3}
par(mai=c(.5,.5,.05,.05), mgp=c(1.2,.3,0), tcl=-.25)
plot(seq(-1,1,.01), seq(-1,1,.01)^3, type="l", ylab=expression("Scaled Pearson Correlation"), xlab="Pearson correlation", ylim=c(-2,2),xlim=c(-1.25,1.25))
points(c(-1.25,1.25), c(-1.25^3,1.25^3),col=2,pch=4)
legend("bottomright", c("E=3","nui=1.25"), bty="n", col=c(NA,2), pch=c(NA,4))
```

## User-Defined Similarities

.. explain csim ..

Advanced users can provide similarity measures themselves by
constructing a "similarity matrix" `csim` where an input cluster
labeling must be integers that serve as row and column indices of this
matrix, ie. similarity between a cluster "2" and a cluster "3" is
stored in `csim[2,3]`. The nuisance cluster is added to this matrix
internally. Construction of `csim` is demonstrated
in the `segment_test` demo, see below.



# Usage

## Installation

From CRAN:

```{r, eval=FALSE}
install.packages("segmenTier")
```

The development version can be obtained from github using
[`devtools`](https://cran.r-project.org/package=devtools):

```{r, eval=FALSE}
library(devtools)
install_github("raim/segmenTier", subdir = "pkg")
```



## Quick Guide

```{r, fig.width=7, fig.height=3}
library(segmenTier)

data(primseg436) # RNA-seq time-series data

# Fourier-transform and cluster time-series:
tset <- processTimeseries(ts=tsd, dft.range=1:7, dc.trafo="ash")
cset <- clusterTimeseries(tset, K=12)
# ... segment it:
segments <- segmentClusters(seq=cset, M=100, E=2, nui=3, S="icor")
# and inspect results:
plotSegmentation(tset, cset, segments, cex=.5, lwd=2)
print(segments)
## and get segment border table for further processing
head(segments$segments)
```



Usage of the package is further demonstrated in two R demos.

## Demo I: Direct Interface to Algorithm

The main low level interface to the algorithm, function
`segmentClusters`, is demonstrated in the file `demo/segment_test.R`.
It produces Supplemental Figure S1 of @Machne2017.

To run it as a demo in R simply type:

```{r, eval=FALSE}
demo("segment_test", package = "segmenTier")
```

## Demo II: Clustering, Batch Segmentation & Parameter Scans

A real-life data set is processed, clustered and segmented with
varying parameters in `demo/segment_data.R`.

This demo runs quite long, since it calculates many segmentations. It
provides a comprehensive overview of the effects of segmentation
parameters `E`, `M` and `nui`, and produces (among others) Figure 3
and Supplemental Figures S4a and S4b of @Machne2017.

```{r, eval=FALSE}
demo("segment_data", package = "segmenTier")
```

# References

