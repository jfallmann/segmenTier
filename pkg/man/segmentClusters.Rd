% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/segment.R
\name{segmentClusters}
\alias{segmentClusters}
\title{Run the \code{segmenTier} algorithm.}
\usage{
segmentClusters(seq, k = 1, csim, E = 1, S = "ccor", M = 175, Mn = 20,
  a = -2, nui = 1, nextmax = TRUE, multi = "max", multib = "max",
  rm.nui = TRUE, save.matrix = FALSE, verb = 1)
}
\arguments{
\item{seq}{either a numeric vector providing a clustering sequence,
or a structure of class 'clustering' as returned by
\code{\link{clusterTimeseries}}. The only strict requirement
for the first option is that nuissance clusters (which will not
be segmented) have to be '0' (zero).}

\item{k}{if argument \code{seq} is of class 'clustering' the kth
clustering will be used; defaults to 1}

\item{csim}{the cluster-cluster or position-cluster similarity
matrix for scoring functions "ccor" and "icor" (option
\code{S}), respectively; where \code{csim} MUST be provided if
argument \code{seq} is a simple vector of clusters; if
\code{seq} is of class 'clustering' \code{csim} will override
the similarity matrix potentially present in
\code{seq}. Finally, for scoring function "ccls" the argument
\code{csim} will be ignored and the matrix instead
automatically constructed from argument \code{a}, and using
argument \code{nui} for the nuissance cluster.}

\item{E}{exponent to scale similarity matrices, must be odd to
maintain negative correlations!}

\item{S}{the scoring function to be used: "ccor", "icor" or "cls"}

\item{M}{minimal sequence length; Note, that this is not a strict
cut-off but defined as a penalty that must be "overcome" by
good score.}

\item{Mn}{minimal sequence length for nuissance cluster, Mn<M will
allow shorter distances between segments; only used in scoring
functions "ccor" and "icor"}

\item{a}{an additional penalty only used for pure cluster-based
scoring w/o cluster similarity measures in scoring function
"cls"}

\item{nui}{the similarity score to be used for nuissance clusters
in the cluster similarity matrices}

\item{nextmax}{go backwards while score is increasing before
openening a new segment, default is TRUE}

\item{multi}{handling of multiple k with max. score in forward
phase, either "min" (default) or "max"}

\item{multib}{handling of multiple k with max. score in back-trace
phase, either "min" (default), "max" or "skip"}

\item{rm.nui}{remove nuissance cluster segments from final results}

\item{save.matrix}{store the total score matrix \code{S(i,c)} and
the backtracing matrix \code{K(i,c)}; useful in testing stage
or for debugging or illustration of the algorithm;}

\item{verb}{level of verbosity, 0: no output, 1: progress messages}
}
\value{
Returns a list (class "segments") containing the main
    result (list item "segments"), and additional information (see
    `Details'). A plot method exists that allows to plot clusters
    aligned to time-series and segmentation plots.
}
\description{
segmenTier's main wrapper interface, calculates segments from a
clustering sequence. This will run the segmentation algorithm once
for the indicated parameters. The function
\code{\link{segmentCluster.batch}} allows for multiple runs over
different parameters or input-clusterings.
}
\details{
This is the main R wrapper function for the `segmenTier'
segmentation algorithm. It takes an ordered sequence of clusterings
and returns segments of consistent clusterings, where cluster-cluster
or cluster-position similarities are maximal. Its main input (argument
\code{seq}) is either an integer vector of cluster associations
(scenario I) or a "clustering" object returned by
\code{\link{clusterTimeseries}} (scenario II). It runs the dynamic
programing algorithm (\code{\link{calculateScore}}) for a selected scoring
function and an according cluster similarity matrix, followed by the
back-tracing step (\code{\link{backtrace}}) to find
segments.
As shown in the publication, the parameters \code{M}, \code{E} and
\code{nui} have the strongest impact on resulting segment borders.
Other parameters can be fine-tuned but had little impact on our
test data set.

In the first scenario I, when the input is a simple clustering vector,
cluster-cluster or cluster-position similarities can be
additionally provided via option \code{csim} for scoring functions
"ccor" and "icor", respectively.  Or, if \code{csim} is missing and
scoring function is "ccls", cluster similarities are constructed
from arguments \code{a} and \code{nui}.  A nuissance cluster must
be indicated by cluster label "0".

In the second scenario II, when the input is an object of class
"clustering" produced by \code{\link{clusterTimeseries}}, the
cluster-cluster and cluster-position similarity matrices are already
provided by this object.

The function returns a list (class "segments") comprising of the
main result (list item "segments"), and "warnings" from the dynamic
programing and back-tracing phases, the used similarity matrix
\code{csim}, extended for nuissance clusters; and optionally (see
option \code{save.matrix}) the scoring vectors \code{S1(i,c)}, the
total score matrix \code{S(i,c)} and the backtracing matrix
\code{K(i,c)}.  It will further contain additional parameters like
cluster colors and sortings if argument \code{seq} was of class
'clustering'. These allow for convenient inspection of all data
processing steps with the plot methods. A plot method exists that
allows to plot segments aligned to "timeseries" and "clustering"
plots.

The main result, list item "segments," is a 3-column matrix,
where column 1 is the cluster assignment and colums 2 and 3 are start and
end indices of the segments. If cluster colors were available in the
input, \code{seq}, a 4th column contains the colors assigned to those
clusters.
}
\examples{
data(primseg436) # RNA-seq time-series data

# 1) Fourier-transform time series:
tset <- processTimeseries(ts=tsd, dft.range=1:7, dc.trafo="ash")
# 2) cluster time-series:
cset <- clusterTimeseries(tset)
# 3) ... segment it:
segments <- segmentClusters(seq=cset, M=100, E=2, nui=3, S="icor")
# 4) and inspect results:
plotSegmentation(tset, cset,segments)

}
\references{
Machne, Murray & Stadler (2017)
    <doi:10.1038/s41598-017-12401-8>
}
