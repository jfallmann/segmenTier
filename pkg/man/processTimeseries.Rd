% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster.R
\name{processTimeseries}
\alias{processTimeseries}
\title{Process a time-series for \code{\link{segmenTier}}.}
\usage{
processTimeseries(ts, trafo = "raw", use.fft = TRUE, dc.trafo = "ash",
  dft.range, perm = 0, use.snr = TRUE, lambda = 1, low.thresh = -Inf,
  smooth.space = 1, smooth.time = 1, circular.time = FALSE, verb = 0)
}
\arguments{
\item{ts}{the timeseries as a matrix, where columns are the timepoints
and rows individual measurements (e.g., genomic positions for transcriptome
data)}

\item{trafo}{prior data transformation, pass any function name, e.g.,
"log", or the package functions "ash" (\code{asinh = ln(x + sqrt(x^2+1))})
or "log_1" for (\code{ln(ts+1)})}

\item{use.fft}{use the Discrete Fourier Transform of the data}

\item{dc.trafo}{data transformation for the first (DC) component of
the DFT, pass any function name, e.g., "log", or the package functions
"ash" (\code{asinh= ln(x + sqrt(x^2+1))}) or "log_1" for (\code{ln(ts+1)}).}

\item{dft.range}{a vector of integers, giving the components of the
Discrete Fourier Transform to be used where 1 is the first component (DC)
corresponding to the mean value, and 2:n are the higher components
correspondong to 2:n full cycles in the data}

\item{perm}{number of permutations of the data set, to obtain}

\item{use.snr}{use a scaled amplitude, where each component of the
Discrete Fourier Transform is divided by the mean of all other components,
which is similar to a signal-to-noise ratio (SNR)}

\item{lambda}{parameter lambda for Box-Cox transformation of
DFT amplitudes (experimental; not tested)}

\item{low.thresh}{use this threshold to cut-off data, which will be
added to the absent/nuissance cluster later}

\item{smooth.space}{integer, if set a moving average is calculated for
each time-point between adjacent data points using stats
package's \code{\link[stats:smooth]{smooth}} with span \code{smooth.space}}

\item{smooth.time}{integer, if set the time-series will be smoothed
using stats package's \code{\link[stats:filter]{filter}} to calculate a
moving average with span \code{smooth.time} and
\code{\link[stats:smoothEnds]{smoothEnds}} to extrapolate smoothed first
and last time-points (again using span \code{smooth.time})}

\item{circular.time}{logical value indicating whether time can be treated
as circular in smoothing}

\item{verb}{level of verbosity, 0: no output, 1: progress messages}
}
\value{
Returns a list of class "time-series" which comprises of the
transformed time-series and additional information, such as the total
signal, and positions of rows with only NA/0 values. Note that NA values
are interpreted as 0.
}
\description{
Prepares the time-series for subsequent clustering, and performs
requested data transformations, including a Discrete
Fourier Transform (DFT) of the time-series as direct input for 
the clustering wrapper \code{\link{clusterTimeseries}}. It can also be used
as a stand-alone function equipped especially for analysis of oscillatory
time-series, including phases and p-values for requested DFT components.
}
\details{
This function exemplifies the processing of an oscillatory
transcriptome time-series data as used in the establishment of this
algorithm and the demo \code{segment_test}. As suggested by Machne & Murray
(PLoS ONE 2012) and Lehmann et al. (BMC Bioinformatics 2014) a Discrete
Fourier Transform of time-series data allows to cluster time-series by
their change pattern. Additional data transformations can be applied (see
documentation of options and example).

This time-series processing and subsequent clustering can also be used
without segmentation, eg. for conventional microarray data or RNA-seq
data already mapped to genes. The option \code{perm} allows to
perform a permutation test (\code{perm} times) and
returns a matrix of empirical p-values for all DFT components, ie. the
fraction of \code{perm} where amplitude was higher then the amplitude
of the randomized time-series.
}
\examples{
data(primseg436)
## The input data is a matrix with time points in columns
## and a 1D order, here 7624 genome positions, is reflected in rows,
## if the time-series should be segmented.
nrow(tsd)
## Time-series processing prepares the data for clustering,
## the example data is periodic, and we will cluster its Discrete Fourier
## Transform (DFT) rather then the original data. Specifically we will
## only use components 1 to 7 of the DFT (dft.range) and also apply
## a signal/noise ratio normalization, where each component is
## divided by the mean of all other components. To de-emphasize
## total levels the first component (DC for "direct current") of the
## DFT will be separately arcsinh transformed. This peculiar combination
## proofed best for our data:
tset <- processTimeseries(ts=tsd, dc.trafo="ash",
                          use.fft=TRUE, dft.range=1:7, use.snr=TRUE)
## a plot method exists for the returned time-series class:
plot(tset)
}
\references{
Machne & Murray (2012) <doi:10.1371/journal.pone.0037906>, and
  Lehmann et al. (2013) <doi:10.1186/1471-2105-14-133>
}
