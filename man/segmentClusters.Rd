% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/segment.R
\name{segmentClusters}
\alias{segmentClusters}
\title{segmenTier's main wrapper interface, calculates segments from a
clustering sequence.}
\usage{
segmentClusters(seq, csim, csim.scale = 1, cset, k = 1, score = "ccor",
  M = 175, Mn = 20, a = -2, nui = 1, nextmax = TRUE, multi = "max",
  multib = "max", ncpu = 1, verb = 1, save.matrix = FALSE)
}
\arguments{
\item{seq}{a clustering sequence. The only strict requirement is that
nuissance clusters (which will not be segmented) have to be numeric or
character "0" (zero).}

\item{csim}{cluster-cluster or position-cluster similarity
matrix, for scoring functions "ccor" and "icor", respectively}

\item{csim.scale}{exponent to scale similarity matrices, must be odd
to maintain negative correlations!}

\item{cset}{alternatively to arguments \code{seq} and \code{csim}, a
set of clusterings as returned by \code{\link{clusterTimeseries}} can
be provided; this requires the additional argument \code{k} to select
the kth clustering from the set}

\item{k}{the kth clustering of argument \code{cset} will be used}

\item{score}{the scoring function to be used: "ccor", "icor" or "cls"}

\item{M}{minimal sequence length; Note, that this is not a strict
cut-off but defined as a penalty that must be "overcome" by good score.}

\item{Mn}{minimal sequence length for nuissance cluster, Mn<M will allow
shorter distances between segments; only used in scoring functions
"ccor" and "icor"}

\item{a}{an additional penalty only used for pure cluster-based
scoring w/o cluster similarity measures in scoring function "cls"}

\item{nui}{the similarity score to be used for nuissance clusters in the
cluster similarity matrices}

\item{nextmax}{go backwards while score is increasing before openening a
new segment, default is TRUE}

\item{multi}{handling of multiple k with max. score in forward phase,
either "min" (default) or "max"}

\item{multib}{handling of multiple k with max. score in back-trace phase,
either "min" (default), "max" or "skip"}

\item{ncpu}{number of available cores (CPUs), passed to
\code{\link[parallel:mclapply]{parallel::mclapply}} by
\code{\link{calculateScoringMatrix}}}

\item{verb}{level of verbosity, 0: no output, 1: progress messages}

\item{save.matrix}{store the total score matrix \code{S(i,c)} and the
backtracing matrix \code{K(i,c)}; useful in testing stage or for
debugging or illustration of the algorithm; see \code{\link{plotScoring}}}
}
\value{
Returns a list containing the main result ("segments"), "warnings"
from the dynamic programing and back-tracing phases, and optionally (see
option \code{save.matrix}) (\code{results$SK}) the total score matrix
\code{S(i,c)} and the backtracing matrix \code{K(i,c)}.
The main result structure "segments" is a 3-column matrix, where column 1
is the cluster assignment and colums 2 and 3 are start and end position
of the segments.
}
\description{
segmenTier's main wrapper interface, calculates segments from a
clustering sequence.
}
\details{
This is the main R wrapper function for the segmentation algorithm.
It takes a sequence of clusterings and returns segments of
consistent clusters. It runs the dynamic programing algorithm for
a selected scoring function and an according cluster similarity matrix,
followed by the  back-tracing step to find segments.
Some more details of the algorithm can be tuned, but these usually
have little effect on real-life data sets.
}

