# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Pearson product-moment correlation coefficient
#' @param x numeric vector
#' @param y numeric vector
#' @details Simply calculates Pearson's product-moment correlation
#' between vectors \code{x} and \code{y}. 
myPearson <- function(x, y) {
    .Call('segmenTier_myPearson', PACKAGE = 'segmenTier', x, y)
}

#' Calculates data-cluster similarity.
#' @details calculates Pearson's product-moment correlation coefficients
#' of original data to cluster centers as used in the scoring function "icor".
#' @param data original data matrix
#' @param clusters cluster centers
#' @return Returns a data-cluster correlation matrix as used in
#' scoring function "icor".
#'@export
clusterCor_c <- function(data, clusters) {
    .Call('segmenTier_clusterCor_c', PACKAGE = 'segmenTier', data, clusters)
}

#' Reports the maximally correlating cluster for each data point.
#' @details Calculates Pearson's product-moment correlation of each data
#' to clusters and report the (first!) cluster which had max correlation.
#' Note that this can lead to amibiguities since several clusters may
#' reach the same maximum.
#' @param mincor minimal correlation to be considered
#' @param warn if set to 1/TRUE then the occurence of multiple maxima
#' is tested and a warning issued
#' @inheritParams clusterCor_c
#'@export
clusterMaxCor_c <- function(data, clusters, mincor = 0.0, warn = 0L) {
    .Call('segmenTier_clusterMaxCor_c', PACKAGE = 'segmenTier', data, clusters, mincor, warn)
}

#' Scoring Function "icor" - Test
#' @details  Scoring function "icor" calculates the sum of similarities of
#' positions k:i to cluster c.
#' The similarities are calculated e.g., as a (Pearson) correlation between
#' the individual positions and the tested cluster c center. 
#' This function is for testing only, the dynamic programming algorithm 
#' uses function ccSMicor.
#' NOTE: individual scoring functions are only used for testing
#' the algorithm uses the matrix-filling functions below
#' @param k start position for score calculation
#' @param i end position for score calculation
#' @param c the cluster to which similarities are to be calculated
#' @param seq the cluster sequence (where positions k:i are considered);
#' notably this is not required here, but used as an argument for
#' consistency with other scoring functions.
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score;
#' set to \code{Mn} if you want to calculate the nuissance cluster score.
#' @param csim position-cluster similarity matrix, where the rows
#' are the positions in the sequence \code{seq} and columns are the
#' the clusters
#' @return Returns the score \code{s(k,i,c)} for cluster \code{c} between
#' the positions \code{k} to \code{i} in the cluster sequence \code{seq},
#' as used in the for scoring function "icor". 
#' @export
scoreicor_c <- function(k, i, c, seq, M, csim) {
    .Call('segmenTier_scoreicor_c', PACKAGE = 'segmenTier', k, i, c, seq, M, csim)
}

#' Scoring Function "cor" - Test
#' @details  Scoring function "cor" calculates the sum of similarities
#' between the clusters at positions k:i to cluster c. Note the difference
#' to "icor" where real data from positions are comapred to clusters, while
#' here two clusters are compared.
#' NOTE: This function is for testing only, the dynamic programming algorithm 
#' uses function ccSMcor.
#' @param k start position for score calculation
#' @param i end position for score calculation
#' @param c the cluster to which similarities are to be calculated
#' @param seq the cluster sequence (where clusters at positions k:i are
#' considered)
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score;
#' set to \code{Mn} if you want to calculate the nuissance cluster score.
#' @param csim cluster-cluster similarity matrix
#' @return Returns the score \code{s(k,i,c)} for cluster \code{c} between
#' the positions \code{k} to \code{i} in the cluster sequence \code{seq},
#' as used in the for scoring function "ccor". 
#' @export
scorecor_c <- function(k, i, c, seq, M, csim) {
    .Call('segmenTier_scorecor_c', PACKAGE = 'segmenTier', k, i, c, seq, M, csim)
}

#' Scoring Function "cls"
#' @details  Scoring function "cls" merely counts the number of
#' of clusters in sequence k:i that are identical to the tested
#' cluster \code{c}, and sub-tracts a minimal size penality
#' and a penalty the for the count of non-identical clusters.
#' NOTE: This function is used in the matrix function ccSMcls.
#' @param k start position for score calculation
#' @param i end position for score calculation
#' @param c the cluster to which similarities are to be calculated
#' @param seq the cluster sequence (where clusters at positions k:i are
#' considered). Note that \code{seq} is defined differently here than
#' in the wrapper interfaces and MUST be a sequence of positive integers >0.
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score.
#' @param a the penalty for non-matching clusters
#' @return Returns the score \code{s(k,i,c)} for cluster \code{c} between
#' the positions \code{k} to \code{i} in the cluster sequence \code{seq}.
#' This is used in the for scoring function "cls".
#' @export
scorecls_c <- function(k, i, c, seq, M, a) {
    .Call('segmenTier_scorecls_c', PACKAGE = 'segmenTier', k, i, c, seq, M, a)
}

#' Scoring Function Matrix "icor"
#' @details  Scoring function "icor" calculates the sum of similarities of
#' data at positions k:i to cluster centers c over all k and i.
#' The similarities are calculated e.g., as a (Pearson) correlation between
#' the data at individual positions and the tested cluster c center.
#' Note the difference to "ccor" where the cluster centers are compared
#' instead of original data at positions k and i with a cluster.
#' @param seq the cluster sequence (where positions k:i are considered);
#' notably this argument is not required here, but only used for
#' consistency with other scoring functions
#' @param c the cluster to which similarities are to be calculated; note, 
#' that c=1 is the nuissance cluster
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score.
#' @param Mn minimal sequence length for nuissance cluster, Mn<M will allow
#' shorter distances between segments; only used in scoring functions
#' "ccor" and "icor" 
#' @param csim position-cluster similarity matrix, where the rows
#' are the positions in the sequence \code{seq} and columns are the
#' the clusters
#' @return Returns the scoring matrix \code{SM(n,n)} for the cluster sequence
#' \code{seq} and cluster \code{c} for scoring function "icor".
#' @export
ccSMicor <- function(seq, c, M, Mn, csim) {
    .Call('segmenTier_ccSMicor', PACKAGE = 'segmenTier', seq, c, M, Mn, csim)
}

#' Scoring Function Matrix "ccor" 
#' @details  Scoring function "ccor" calculates the sum of similarities
#' between the clusters at positions k:i to cluster c over all k and i.
#' Note the difference to "icor" where real data from positions are
#' compared to cluster centers, while here two cluster centers are compared.
#' @param seq the cluster sequence (where clusters at positions k:i are
#' considered). Note that \code{seq} is defined differently here than
#' the wrapper interfaces and MUST be a sequence of positive integers >0.
#' @param c the cluster to which similarities are to be calculated
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score.
#' @param Mn minimal sequence length for nuissance cluster, Mn<M will allow
#' shorter distances between segments; only used in scoring functions
#' "ccor" and "icor" 
#' @param csim cluster-cluster similarity matrix
#' @return Returns the scoring matrix \code{SM(n,n)} for the cluster sequence
#' \code{seq} and cluster \code{c} for scoring function "ccor".
#' @export
ccSMccor <- function(seq, c, M, Mn, csim) {
    .Call('segmenTier_ccSMccor', PACKAGE = 'segmenTier', seq, c, M, Mn, csim)
}

#' like ccSMccor, but also calculates scores for the nuissance cluster 
#' @inheritParams ccSMccor
#' @export
ccSMncor <- function(seq, c, M, Mn, csim) {
    .Call('segmenTier_ccSMncor', PACKAGE = 'segmenTier', seq, c, M, Mn, csim)
}

#' Scoring Function Matrix "cls"
#' @details  Scoring function "cls" merely counts the number of
#' of clusters in sequence k:i, over all k and i, that are identical
#' to the tested cluster \code{c}, and sub-tracts a minimal size penality
#' and a penalty the for the count of non-identical clusters.
#' Note: this function used in the scoring unction scorecls_c for individual
#' calculations.
#' @param seq the cluster sequence (where clusters at positions k:i are
#' considered). Note that \code{seq} is defined differently here than
#' in the wrapper interfaces and MUST be a sequence of positive integers >0.
#' @param c the cluster to which similarities are to be calculated
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score.
#' @param Mn minimal sequence length for nuissance cluster, Mn<M will allow
#' shorter distances between segments; only used in scoring functions
#' "ccor" and "icor" 
#' @param csim integer, the penalty \code{a} for non-matching clusters
#' @return Returns the scoring matrix \code{SM(n,n)} for the cluster sequence
#' \code{seq} and cluster \code{c} for simplest scoring function "cls".
#' @export
ccSMcls <- function(seq, c, M, Mn, csim) {
    .Call('segmenTier_ccSMcls', PACKAGE = 'segmenTier', seq, c, M, Mn, csim)
}

#' dynamic programming routine 
#' @details: This is \code{\link{segmenTier}}'s core dynamic programing
#' routine. It takes the scoring function matrices for all clusters,
#'  and dynamically constructs the total score matrix S(i,c).
#' @param seq the cluster sequence (where clusters at positions k:i are
#' considered). 
#' @param C the list of clusters
#' @param SM list of scoring function matrices
#' @param multi if multiple \code{k} are found which return the same maximal
#' score, should the "max" (shortest distance) or "min" \code{k} be used?
#' This has little effect on real-life large data sets, since the situation
#' will rarely occur. Default is "max".
#' @param verb level of verbosity, currently not used (TODO: rm?)
#' @return Returns the total score matrix \code{S(i,c)} and the matrix 
#' \code{K(i,c)} which stores the position \code{k} which delivered
#' the maximal score at position \code{i}. This is used in the back-tracing
#' phase.
#' @export
calculateTotalScore <- function(seq, C, SM, multi = "max", verb = 1L) {
    .Call('segmenTier_calculateTotalScore', PACKAGE = 'segmenTier', seq, C, SM, multi, verb)
}

