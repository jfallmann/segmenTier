# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Pearson product-moment correlation coefficient
#' @param x numeric vector
#' @param y numeric vector
#' @details Simply calculates Pearson's product-moment correlation
#' between vectors \code{x} and \code{y}. 
myPearson <- function(x, y) {
    .Call('segmenTier_myPearson', PACKAGE = 'segmenTier', x, y)
}

#' Calculates data-cluster similarity.
#' @details calculates Pearson's product-moment correlation coefficients
#' of original data to cluster centers as used in the scoring function "icor".
#' @param data original data matrix
#' @param clusters cluster centers
#' @return Returns a data-cluster correlation matrix as used in
#' scoring function "icor".
#'@export
clusterCor_c <- function(data, clusters) {
    .Call('segmenTier_clusterCor_c', PACKAGE = 'segmenTier', data, clusters)
}

#' Reports the maximally correlating cluster for each data point.
#' @details Calculates Pearson's product-moment correlation of each data
#' to clusters and report the (first!) cluster which had max correlation.
#' Note that this can lead to amibiguities since several clusters may
#' reach the same maximum.
#' @param mincor minimal correlation to be considered
#' @param warn if set to 1/TRUE then the occurence of multiple maxima
#' is tested and a warning issued
#' @inheritParams clusterCor_c
#'@export
clusterMaxCor_c <- function(data, clusters, mincor = 0.0, warn = 0L) {
    .Call('segmenTier_clusterMaxCor_c', PACKAGE = 'segmenTier', data, clusters, mincor, warn)
}

icor <- function(k, j, c, seq, M, csim) {
    .Call('segmenTier_icor', PACKAGE = 'segmenTier', k, j, c, seq, M, csim)
}

ccor <- function(k, j, c, seq, M, csim) {
    .Call('segmenTier_ccor', PACKAGE = 'segmenTier', k, j, c, seq, M, csim)
}

#' Scoring Function "icor" - Test
#' @details  Scoring function "icor" calculates the sum of similarities of
#' positions k:i to cluster c.
#' The similarities are calculated e.g., as a (Pearson) correlation between
#' the individual positions and the tested cluster c center. 
#' This function is for testing only, the dynamic programming algorithm 
#' uses function ccSMicor.
#' NOTE: individual scoring functions are only used for testing
#' the algorithm uses the matrix-filling functions below
#' @param k start position for score calculation
#' @param i end position for score calculation
#' @param c the cluster to which similarities are to be calculated
#' @param seq the cluster sequence (where positions k:i are considered);
#' notably this is not required here, but used as an argument for
#' consistency with other scoring functions.
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score;
#' set to \code{Mn} if you want to calculate the nuissance cluster score.
#' @param csim position-cluster similarity matrix, where the rows
#' are the positions in the sequence \code{seq} and columns are the
#' the clusters
#' @return Returns the score \code{s(k,i,c)} for cluster \code{c} between
#' the positions \code{k} to \code{i} in the cluster sequence \code{seq},
#' as used in the for scoring function "icor". 
#' @export
scoreicor_c <- function(k, i, c, seq, M, csim) {
    .Call('segmenTier_scoreicor_c', PACKAGE = 'segmenTier', k, i, c, seq, M, csim)
}

#' Scoring Function "cor" - Test
#' @details  Scoring function "cor" calculates the sum of similarities
#' between the clusters at positions k:i to cluster c. Note the difference
#' to "icor" where real data from positions are comapred to clusters, while
#' here two clusters are compared.
#' NOTE: This function is for testing only, the dynamic programming algorithm 
#' uses function ccSMcor.
#' @param k start position for score calculation
#' @param i end position for score calculation
#' @param c the cluster to which similarities are to be calculated
#' @param seq the cluster sequence (where clusters at positions k:i are
#' considered)
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score;
#' set to \code{Mn} if you want to calculate the nuissance cluster score.
#' @param csim cluster-cluster similarity matrix
#' @return Returns the score \code{s(k,i,c)} for cluster \code{c} between
#' the positions \code{k} to \code{i} in the cluster sequence \code{seq},
#' as used in the for scoring function "ccor". 
#' @export
scorecor_c <- function(k, i, c, seq, M, csim) {
    .Call('segmenTier_scorecor_c', PACKAGE = 'segmenTier', k, i, c, seq, M, csim)
}

#' Scoring Function "cls"
#' @details  Scoring function "cls" merely counts the number of
#' of clusters in sequence k:i that are identical to the tested
#' cluster \code{c}, and sub-tracts a minimal size penality
#' and a penalty the for the count of non-identical clusters.
#' NOTE: This function is used in the matrix function ccSMcls.
#' @param k start position for score calculation
#' @param i end position for score calculation
#' @param c the cluster to which similarities are to be calculated
#' @param seq the cluster sequence (where clusters at positions k:i are
#' considered). Note that \code{seq} is defined differently here than
#' in the wrapper interfaces and MUST be a sequence of positive integers >0.
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score.
#' @param a the penalty for non-matching clusters
#' @return Returns the score \code{s(k,i,c)} for cluster \code{c} between
#' the positions \code{k} to \code{i} in the cluster sequence \code{seq}.
#' This is used in the for scoring function "cls".
#' @export
scorecls_c <- function(k, i, c, seq, M, a) {
    .Call('segmenTier_scorecls_c', PACKAGE = 'segmenTier', k, i, c, seq, M, a)
}

#' dynamic programming routine 
#' @details: This is \code{\link{segmenTier}}'s core dynamic programing
#' routine. It constructs the total score matrix S(i,c), based on
#' the passed scoring function ("icor" or "ccor")
#' Scoring function "icor" calculates the sum of similarities of
#' data at positions k:i to cluster centers c over all k and i.
#' The similarities are calculated e.g., as a (Pearson) correlation between
#' the data at individual positions and the tested cluster c center.
#' Note the difference to "ccor" where the cluster centers are compared
#' instead of original data at positions k and i with a cluster.
#' Scoring function "ccor" calculates the sum of similarities
#' between the clusters at positions k:i to cluster c over all k and i.
#' Note the difference to "icor" where real data from positions are
#' compared to cluster centers, while here two cluster centers are compared.
#' Scoring function "ccls" is a special case of "ccor" and is NOT handled
#' here, but is reflected in the cluster similarity matrix \code{csim}. It
#' is handled and automatically constructed in the R wrapper 
#' \code{\link{clusterSegments}}, and merely counts the 
#' number of clusters in sequence k:i, over all k and i, that are identical
#' to the tested cluster \code{c}, and sub-tracts a minimal size penality
#' and a penalty the for the count of non-identical clusters.
#' @param seq the cluster sequence (where clusters at positions k:i are
#' considered). Note, that unlike the R wrapper, clustering numbers
#' here are 0-based, where 0 is the nuissance cluster.
#' @param C the list of clusters, including nuissance cluster '0', see 
#' \code{seq}
#' @param score the scoring function to be used, one of "ccor" or "icor";
#' the scoring function "ccls" is a special case of "ccor" and should
#' be handled via the similarity function (matrix) "csim" as e.g. done
#' by the R wrapper function \code{\link{segmentClusters}}. See "details".
#' @param M minimal sequence length; Note, that this is not a strict
#' cut-off but defined as a penalty that must be "overcome" by good score.
#' @param Mn minimal sequence length for nuissance cluster, Mn<M will allow
#' shorter distances between segments
#' @param csim a matrix, providing either the cluster-cluster (scoring 
#' function "ccor") or the position-cluster similarity function
#' @param multi if multiple \code{k} are found which return the same maximal
#' score, should the "max" (shorter segment) or "min" (longer segment) be used?
#' This has little effect on real-life large data sets, since the situation
#' will rarely occur. Default is "max".
#' @return Returns the total score matrix \code{S(i,c)} and the matrix 
#' \code{K(i,c)} which stores the position \code{k} which delivered
#' the maximal score at position \code{i}. This is used in the back-tracing
#' phase.
#' @export
calculateScore <- function(seq, C, score, csim, M, Mn, multi = "max") {
    .Call('segmenTier_calculateScore', PACKAGE = 'segmenTier', seq, C, score, csim, M, Mn, multi)
}

